<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: routes.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: routes.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.routes = exports.isUUID = void 0;
const Keyv = require("keyv");
const bcrypt = require("bcrypt");
const uuid_1 = require("uuid");
const client_1 = require("@prisma/client");
const config_1 = require("../config");
const messages_1 = require("../messages");
const isDev = config_1.config.env === 'dev';
const prisma = new client_1.PrismaClient();
// Const keyv = new Keyv("redis://user:pass@localhost:6379")
const keyv = new Keyv({ serialize: JSON.stringify, deserialize: JSON.parse });
exports.isUUID = (uuid, uuidVersion) => uuid_1.validate(uuid) &amp;&amp; uuid_1.version(uuid) === uuidVersion;
const emailExist = async (email) => {
    const userWithEmail = await prisma.user.findOne({
        where: {
            email
        }
    });
    if (userWithEmail !== null) {
        return true;
    }
    return false;
};
const authPreHandler = async (request, reply, done) => {
    if (!request.cookies ||
        !(config_1.config.AUTH_COOKIE_NAME in request.cookies) ||
        !exports.isUUID(request.cookies[config_1.config.AUTH_COOKIE_NAME], 4)) {
        return reply.code(401).send({ message: messages_1.messages.auth.INVALID_COOKIE });
    }
    const { token } = request.cookies;
    let auth = await keyv.get(token);
    if (!auth) {
        const userFromToken = await prisma.auth.findOne({
            where: { token },
            include: { User: true }
        });
        if (!userFromToken) {
            return reply.code(403).send({ message: messages_1.messages.auth.EXPIRED_COOKIE });
        }
        auth = userFromToken;
    }
    await keyv.set(token, auth, 120 * 1000);
    request.auth = auth;
    done();
};
/**
 * Register a new user
 *
 * @name Auth
 * @path {POST} /auth/register
 * @code {200} if the request is successful
 * @code {400} if email already exist
 * @body {String} email Email used for registration
 * @body {String} password Password used for registration
 */
const registerHandler = async (request, reply) => {
    const { email, password } = request.body;
    const isEmailExist = await emailExist(email);
    if (isEmailExist) {
        return reply.code(400).send({ message: messages_1.messages.auth.EMAIL_ALREADY_IN_USE });
    }
    const hashedPassword = await bcrypt.hash(password, config_1.config.PASSWORD_SALT_ROUNDS);
    const user = await prisma.user.create({
        data: {
            id: uuid_1.v4(),
            email,
            password: hashedPassword
        }
    });
    return reply.code(200).send({
        data: { user },
        message: messages_1.messages.auth.REGISTERED
    });
};
/**
 * Login a new user
 *
 * @name Auth
 * @path {POST} /auth/login
 * @code {200} if the request is successful
 * @code {400} if email already exist
 * @body {String} email Email used for registration
 * @body {String} password Password used for registration
 */
const loginHandler = async (request, reply) => {
    const { email, password } = request.body;
    const user = await prisma.user.findOne({
        where: { email }
    });
    if (!user) {
        return reply.code(401).send({
            message: messages_1.messages.auth.INVALID_CREDENTIALS
        });
    }
    const compare = await bcrypt.compare(password, user.password);
    if (!compare) {
        return reply.code(401).send({
            message: messages_1.messages.auth.INVALID_CREDENTIALS
        });
    }
    const token = uuid_1.v4();
    await prisma.auth.create({
        data: {
            token,
            ip: request.ip,
            User: {
                connect: { id: user.id }
            }
        }
    });
    return reply.setCookie(config_1.config.AUTH_COOKIE_NAME, token).send({
        data: {
            session_token: token,
            ...user
        },
        message: messages_1.messages.auth.LOGGED_IN
    });
};
/**
 * Logout an authenticated user
 *
 * @name Auth
 * @path {DELETE} /auth/logout
 * @code {200} if the request is successful
 * @auth This route requires a valid token cookie set in headers
 * @code {401} if no cookies or malformed cookie
 * @code {403} if expired cookie
 * @code {500} if something went wrong
 */
const logoutHandler = async (request, reply) => {
    const { token } = request.auth;
    await Promise.all([prisma.auth.delete({ where: { token } }), keyv.delete(token)]);
    reply.code(200).clearCookie(config_1.config.AUTH_COOKIE_NAME).send();
};
/**
 * Revoke all others auth tokens
 *
 * @name Auth
 * @path {DELETE} /auth/logout-all
 * @code {200} if the request is successful
 * @auth This route requires a valid token cookie set in headers
 * @code {401} if no cookies or malformed cookie
 * @code {403} if expired cookie
 * @code {500} if something went wrong
 */
const logoutAllHandler = async (request, reply) => {
    const { token, id } = request.auth;
    await prisma.auth.deleteMany({
        where: { id, NOT: { token } }
    });
    reply.code(200).send();
};
/**
 * Forgot password (wip - experimental)
 *
 * @name Auth
 * @path {POST} /auth/forgot-password
 * @code {400} if missing parameters
 * @code {401} if no existing user with email
 * @code {200} if the request is successful
 */
const forgotPasswordHandler = async (request, reply) => {
    const { email } = request.body;
    if (!email) {
        return reply.code(400).send();
    }
    const userFromEmail = await prisma.user.findOne({ where: { email } });
    if (userFromEmail === null) {
        return reply.code(401).send();
    }
    const resetToken = uuid_1.v4();
    const sendMail = async () => {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                // Send email to user
                console.log('Email sent');
                resolve();
            }, 500);
        });
    };
    await Promise.all([
        await keyv.set(`forgot:${email}`, resetToken, isDev ? 300 * 1000 : config_1.config.FORGOT_PASSWORD_EXPIRY_SEC),
        await keyv.set(`forgot:${resetToken}`, userFromEmail, isDev ? 300 * 1000 : config_1.config.FORGOT_PASSWORD_EXPIRY_SEC),
        sendMail
    ]);
    console.log('resetToken', resetToken);
    reply.code(200).send({ message: messages_1.messages.auth.GENERATE_TOKEN_SENT });
};
/**
 * Reset password (wip - experimental)
 *
 * @name Auth
 * @path {POST} /auth/forgot-password
 * @code {400} if missing parameters
 * @code {401} if invalid reset token user with email
 * @code {200} if the request is successful
 */
const resetPasswordHandler = async (request, reply) => {
    const { token, newPassword } = request.body;
    if (!token || !newPassword) {
        return reply.code(400).send();
    }
    const forgotKey = `forgot:${token}`;
    const isValidToken = await keyv.get(forgotKey);
    const emailKey = `forgot:${isValidToken.email}`;
    const lastIssuedToken = await keyv.get(emailKey);
    console.log({ isValidToken, lastIssuedToken });
    if (!isValidToken || lastIssuedToken !== token) {
        return reply
            .code(401)
            .send({ message: messages_1.messages.auth.INVALID_OR_EXPIRED_TOKEN });
    }
    const hashedNewPassword = await bcrypt.hash(newPassword, config_1.config.PASSWORD_SALT_ROUNDS);
    const updatePassword = prisma.user.update({
        where: { id: isValidToken.id },
        data: {
            password: hashedNewPassword
        }
    });
    await Promise.all([updatePassword, keyv.delete(forgotKey)]);
    return reply.code(200).send({ message: messages_1.messages.auth.RESET_PASSWORD_SUCCEEDED });
};
/**
 * Delete my account
 *
 * @name Auth
 * @path {DELETE} /auth/me
 * @code {400} if missing parameter
 * @code {200} if the request is successful
 * @auth This route requires a valid token cookie set in headers
 * @code {401} if no cookies or malformed cookie
 * @code {403} if expired cookie
 * @code {500} if something went wrong
 * @body {String} id User's id to delete
 */
const deleteMeHandler = async (request, reply) => {
    const { id } = request.auth;
    if (!id) {
        return reply.code(400).send();
    }
    await prisma.user.delete({ where: { id } });
    reply
        .code(200)
        .clearCookie(config_1.config.AUTH_COOKIE_NAME)
        .send({ message: messages_1.messages.auth.USER_DELETED });
};
const register = {
    schema: {
        body: {
            type: 'object',
            required: ['email', 'password'],
            properties: {
                email: { type: 'string', format: 'email' },
                password: { type: 'string' }
            }
        }
    },
    handler: registerHandler
};
const login = {
    schema: register.schema,
    handler: loginHandler
};
const logout = {
    handler: logoutHandler,
    preHandler: authPreHandler
};
const logoutAll = {
    handler: logoutAllHandler,
    preHandler: authPreHandler
};
const deleteMe = {
    handler: deleteMeHandler,
    preHandler: authPreHandler
};
const forgotPassword = {
    schema: {
        body: {
            type: 'object',
            required: ['email'],
            properties: {
                email: { type: 'string', format: 'email' }
            }
        }
    },
    handler: forgotPasswordHandler
};
const resetPassword = {
    schema: {
        body: {
            type: 'object',
            required: ['token', 'newPassword'],
            properties: {
                token: { type: 'string', format: 'uuid' },
                newPassword: { type: 'string' }
            }
        }
    },
    handler: resetPasswordHandler
};
// exported routes
exports.routes = [
    { method: 'POST', url: '/auth/register', ...register },
    { method: 'POST', url: '/auth/login', ...login },
    { method: 'POST', url: '/auth/forgot-password', ...forgotPassword },
    { method: 'POST', url: '/auth/reset-password', ...resetPassword },
    { method: 'DELETE', url: '/auth/me', ...deleteMe },
    { method: 'DELETE', url: '/auth/logout', ...logout },
    { method: 'DELETE', url: '/auth/logout-all', ...logoutAll }
];
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html">Auth</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Sun Nov 22 2020 15:35:15 GMT+0000 (Greenwich Mean Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
